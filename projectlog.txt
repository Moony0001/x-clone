1.  Create the project file "Twitter Clone"
2.  Add two folders to it, one named "backend" the other named "frontend" 
3.  In the frontend folder, initialise a new react app. To do that first cd into the frontend folder then in the terminal type the
    command "npm vite@latest .", the dot at the end is for when we want the react app to be initialised under the frontend folder,
    i.e. under the same folder that we have cd into, else it would prompt us to name a new directory for creating the app, select Y
    when prompted then "React" when prompted then "JavaScript" when prompted.
    Now run the command "npm i" to install all the node modules and dependencies and once that has been done run "npm run dev" to 
    see the boiler plate react app.
4.  Now to be able to create a backend we will cd into the backend folder. Before that we will run the command "npm init -y" in
    the root just to have a better developer experience when we deploy this app. This command will give us the package.json file, so
    that we could install our dependencies. For the backend we would like to install a couple of dependencies. So, run the 
    "npm install express mongoose jsonwebtoken bcryptjs dotenv cors cookie-parser cloudinary"
    express: to create our api or the express server
    mongoose: to interact with our mongodb database
    jsonwebtoken: for authentication
    bcryptjs: to be able to hash passwords
    dotenv: to be able to read the content of .env file
    cors: to be able to get rid of cors errors
    cookie-parser: to be able to get the cookies from the request
    cloudinary: (package/service) so that we could upload images for free
    The above command will install all the packages and put the node modules in our root. We also install a dev dependency, for
    that the command will be "npm i -D nodemon". Add the "type" key in the package.json file below the "author" key and set it to
    "module" in order to use the import and export syntax. For the scripts, delete the "test" key and then write
    ' "dev":"nodemon backend/server.js" ' to be able to run nodemon. The "server.js" file will be under the "backend" folder 
    (create one) hence the path after the nodemon. And for the production we will write ' "start" : "node backend/server.js" '
    and this means we want to run this file with node. Our main file is not "index.js" anymore but "server.js" under the "backend"
    folder so we will change the value of the "main" key to "backend/server.js".
    Now, calling the command "npm run dev" will call the "nodemon backend/server.js" and run the server.js file. Since we are 
    using nodemon, whenever we change the server.js file it is just going to update the server and restart the server by default.
    Hence, nodemon is a very useful tool for development.
5.  Create your boilerplate express server in the "server.js" to test it out.
    ' import express from "express";

    const app = express();

    app.get("/", (req,res)=>{
        res.send("Server is ready");
    })

    app.listen(8000, ()=>{
        console.log("Server is up and running on port 8000")
    }) '
6.  Now, that we have our setup, we can setup our other routes. We will have a couple of different services like authentication,
    users, posts, notifications and adding all of these to one file would make the file really large and hard to manage. Hence,
    instead we will put routes in different folders. So, we create a "routes" folder in our backend folder and this folder is 
    going to have some functions and again we can't put all of them into those files so instead we'll like to have some clean code 
    and some manageable and maintainable code base and for that we are going to create a folder called "controllers" and we would 
    like to have some tables in our database and we're going to call them "models" and since we are using mongodb which is a nosql
    database so it is not going to be tables but something called as collections but basically it is the same thing as tables.
7.  We add a middleware using "app.use" which says that when we visit "api/auth" we would like to go to "authRoutes". And this 
    route we need to add to the routes folder by the name of "auth.routes.js" or any other name that we want. In this we add the
    routes that will handle all the authentication endpoints. We use the "express.Router" instance and using this in a const 
    variable we use the HTTP methods that we want to add to the route along with the path that we want it to follow or the 
    endpoint that we want there. In the handler function we add the objects that we want it to return on hitting that endpoint.
    We will use the POST methods for authentication and their handler functions also need to be put in the "auth.controller.js"
    file that is to be created in the "controllers" folder and the reason is that if any of the handler functions become too 
    large, the file will be unmanageable and it is the best practise to create the "controller" folder and the file in it.
8.  To set up our signup functionality, we need a database to store our users and for this we need mongodb. So, we go to the
    mongodb website and signin and create a new project. Then we create a new deployment selecting the free tier leaving the 
    cluster name as it is. Now, this is going to give us a password which we need to copy and then create a .env file in our 
    root folder and paste the password in it. Then we click "Create Database User" and then "Choose a Connection Method",
    select the Drivers because we would like to connect the mongodb with node.js. It will say to install mongodb but we have
    installed mongoose which is better option as it has really great support. Then we will copy the connection string with the
    checkbox checked for "Show Password" and we will paste this string in the .env file as well. As we have copied the string
    with the password, we will delete the previously pasted password from the .env file and set the link string equal to a
    variable, in our case the variable name is MONGO_URI. In the link string, before the '?' symbol we will add the database
    name, in our case twitter-db. And with this we should be able to connect to our mongo database. Now, we will go under the
    "Network Access" and in this there should be our IP address and in this we will add another IP address and then select the
    option "Allow access from anywhere" beccause our IP addresses could change while developing the application and we don't
    want to get any errors.
9.  Now, we can write a function to be able to connect to our database. We installed the dotenv dependency to be able to read the
    .env file content. So, to use this dependency, we first import the dotenv file from dotenv then configure the dotenv by
    "dotenv.config();" and then use "process.env.MONGO_URI" to access the variable. Now, we are going to create a folder called
    "db" and add a file called "connectMongoDB.js". Inside this file we will just create a function to be able to connect. Now, 
    once we listen to our server, once our server is up and running we are going to just say connectMongoDB and just call it.
    We can also add the port number to the .env file and call it in the server.js file along with a default value and set it as
    a variable.
    At this point, you can commit your files to a Git Repo. For that, we move the .gitignore file from the frontend folder to
    the root folder and add the .env add the end of it. Then in a new terminal with the folder set as the root directory we call
    'git init' and then stage our changes using the Git extension of vscode and then add our commit message and then commit.
10. Now, we will first try to create our user model. So, we will add the "user.model.js" file to the "models" folder of the
    backend. A model is kind of a table and since we are using nosql its going to be like a collection. In this we create the 
    user schema with the first object passed in the schema being the various attributes of that schema/ fields of the user along 
    with its constraints like type, required, unique etc. The second object to be passed in the Schema call is optional but useful
    when we want to add member since: or created on: or updated on: fields for the user, for this we set the timestamp key as true.
    Once the schema is done, we created the model User using the line mongoose.model("User", userSchema); and then exported User model
11. Now, with our User model implemented and exported we can implement the user authentication route and specifically the signup
    function. So in the auth.controller.js file we implement the handler functions. We need to get some fields from the user like
    fullName, userName, email, password and we will get that from req.body but we cannot get this without using the middleware.
    Middleware is just a function that runs before you do anything or after you do everything or just something in between, the thing
    to remember is that it is a reqular function that runs between request and response. In our case we will use the express.json 
    middleware in order to be able to parse the request body or the req.body and that is going to be the form data that is coming
    from the user from the React application. Now that we have all those fields, for signup, first we check whether the email given
    by the user in the signup form is valid or not, we check that using a regular expression and the test method. After this we 
    check whether the user already has an account or not by checking in our user database if the email given by the user matches any
    email already stored in the database, we do the same for username as well. After this, we hash the password provided by the user.
    For this we use the bcrypt package. First we import the package bcrypt, then we generate the salt using the genSalt method and 
    the generation of salt takes time so we add the await keyword in front of it. The genSalt method takes the salt length value as
    a parameter and the optimal value is considered to be 10, the larger this value the longer it takes for the salt to be generated.
    Then we call the hash method and pass it the password that the user filled in the form and the salt that was generated. Now, we 
    create an object for the new user called newUser object which has the instance of the User model which is passed the object with 
    the passed values and the hashedpassword. Now, once we have the user we would like to generate a token and set the cookie and
    this token will be jsonwebtoken. For this we write an if-else statement in which if the user is generated successfully then we
    call the generateTokenAndSetCookie function that has not been created yet but will take the parameter as the newUser._id and the
    res or response. Next, we save the user information to the database using the save method and finally send a status code of 201
    with the json containing the users information including it's profileImg coverImg etc. set as the default value, finally we send
    a 400 error in the else case and a 500 error in the catch block with a debugging friendly logging of the error.
12. Now, we move on to create the generateTokenAndSetCookie method. For that we create a new folder in our backend folder called
    "lib" and inside this folder we create another folder called "utils" and inside this we create the generateToken.js file. In this
    file we first import the jwt from jsonwebtoken and then export the function that we created generateTokenAndSetCookie, inside this
    it takes the parameter as the userId as well as the res because we're going to set a cookie and send it back to the client as a 
    response. In this we create the const token that calls the sign method that takes the userId as a payload so that we could identify
    this user with some value and that is going to be the userId, as well as something called as the JWT_SECRET, we also set the 
    duration in which the cookie will expire. We need to create the JWT_SECRET in our .env file. This could be any value but we will
    create a long one using our terminal. Open the GitBash terminal and type the command "openssl rand -base64 32" and this will give 
    us a value that we can just copy and paste it in our .env file to be saved into a variable JWT_SECRET. With our secret set, we now 
    have the token and we would like to send it to the client as a cookie. For that we set first the name of the cookie, then we pass
    the token that we want the server to send to the client and then the properties of the cookie that we want to set such as 
    maximum age of the cookie, whether it cannot be accessed by client side i.e. httpOnly, the sameSite attribute for CSRF attacks, 
    whether we want to use the https protocol to send the cookie or not. For https too we will need to set another node environment 
    variable in our .env file that will be set to the string "development" until we are in the development phase and once we deploy
    our application, it will be changed to "production". Now to test this out, we will use PostMan. To do that, first create a
    workspace for your project, then add a collection called AUTH to the workspace, inside that add a request with name SIGNUP and
    the method POST and then in the URL add the protocol name (http://) followed by localhost: followed by our port number of The
    application, followed by /api/auth/signup, then we go to the body tab under it the raw type and the dropdown being JSON. But,
    instead of passing all the user inputs in a JSON file, it is more convenient to use the form-urlencoded way, so we add another
    middleware in the server.js file, just after the app.use(express.json) for parsing the urlencoded form data from the request.
    Then we pass the attribute that we want to set as the key in the form, the name of the attribute should be exactly the same as
    that used in the backend. Make sure that you are sending the form input through body and urlencoded and not the params tab.
    We can check the entries in our database by going to mongodb and database.
13. Now, we will add the login functionality. For this too we will use a try-catch block with the catch block having the same code
    as the signup controller. Here, we will take the username and password from the req.body and then first check to see if the user
    actually exists or not in the database. Then we will go ahead and check if the password provided by the user is correct or not,
    given that the user actaully exists. If the user is genuine, then we will generate a cookie for that user and send it to the user,
    just like in signup.
14. Now, the logout functionality is very easy to implement, we just send a cookie as a response to the post request with its maxage
    as 0 so that it immediately kills that and then return a res status of 200. 
15. One last controller that we need to add is the getMe which will get the authenticated user. This will be used to check whether the
    user is authenticated or not. To implement this, we initiate the try-catch block inside this we try to find the user by user._id
    taking it from the req.body, but in request, we don't have the user._id field so we need to add this first. So in our 
    auth.routes.js file, we have three different post methods, and at the top we will create another one router.get where we get the
    currently authenticated user, but this should be a protected function so we add a middleware, in between the endpoint and the 
    function name called protectRoute and then we create a folder in the backend folder called the "middleware" and inside this we
    add the protectRoute.js file. The reason behind validating the authentication of the user is that whenever we want to perform some 
    other functionalities, we need to be sure that it is infact the user is using that functionality, for that we send the cookie to 
    the server and the server decodes this cookie to authenticate the user and perform the functionality that the user wanted to 
    perform. To do this validity check, we write the protectRoute function using the try-catch block. In this too we first try to get 
    the token from the req but we need a middleware to parse the cookie so we use the cookieParser middleware and add it to the 
    server.js, now the token can be obtained. Now, if there is no token, we throw a token not found error, however, if there is in 
    fact a token, then that token is decoded using the JWT_SECRET that we stored. And if the decoded returns some faulty value or it
    is expired then we will return invalid token. Then we find the user by its id that was passed as a payload and exclude the 
    password field from it. Next we add a just in case for user not being found and finally we set the user object of the request
    equal to the user and then we call the next function. So, in our protectRoute, basically we are getting the token from the cookies
    and if there is not a token, we handle it, if there is a cookie but it is invalid, again we handle it, and we need to verify this
    token with that secret that we have created previously and if we pass this then it means we have a valid token and we use the 
    valid userId to find our user in the database while removing the password field from it and pass this to the req object. Then the
    next is going to call the next function i.e. getMe in this case. Now, in the getMe function, we can use the req.user._id and 
    send that user back to the client. With this, we have all of our controllers in place for our authenication.
16. Now, we move on to the user controller functions. For that, we will add the route so that whenever we go to the /users route, it
    goes through the userRoutes. Now, we create a user.routes.js file in our routes folder and import it into our server.js. Inside
    the user.routes.js file we add the different endpoints that we want to handle like the profile of the user, the suggestions that
    we will provide to the user will also be handled in this route, the follow and unfollow endpoint and the profile updation route.
    All of these routes will also be protected i.e. the user would need to be authenticated to access all these endpoints for obvious
    reasons. Now, we will create the functions that will be called on visiting the specific endpoints. To do that first we create 
    user.routes.js file under the routes folder and inside this file, we add the handler functions. The first function is to get the
    user profile, we are going to be using this when we visit a user profile, so in the profile page where we can see their name, 
    username, folllowers, following etc. To get the user profile, we will take the user name from the params of the URL and use it to
    find the user. 
17. Next, we write the function for the followUnfollow handler. The catch block for this one will be similar to the previous one.
    Now, in this endpoint too, we are passing a param of id which we will use to find which user we would like to follow or unfollow.
    Now, there are two different users that we would like to modify, the user that we would like to follow or unfollow and the current
    user. We will use the id passed as params to get the user to modify and the current user as the user._id that we specified in 
    the protectRoute i.e. the user who wants to follow or unfollow. Now, we perform basic checks to see whether the user is not
    following himself/herself or if the user to modify or the current user exists or not. Then we will check whether the user already
    follows the user or not, if it does follow the user, it will unfollow the user and if it doesn't follow the user then it will
    follow the user. So, if user 1 follows user 2 then user 1 will have an id added to its following array and the user 2 will have
    an id added to its followers array and vice versa happens for unfollowing a user. For adding an id into the array we use the push
    operation of mongodb and the pull operation to remove an id from the array.

18. Now, we add the notifications functionality to the follow/unfollow i.e. a notification will be sent to the user that was followed
    informing them about who followed them but no notification will be given to inform them when they are unfollowed by someone else.
    In order to implement the notification functionality we will create a notification model inside the models folder with the name
    notification.model.js. Inside it we will import mongoose and then create a notification schema and add the timestamps parameter
    to it for later use. Each notification will have a from field, to field, type field and read field. Now, we create a model of the
    Notification schema and export it. We import this in the user.controllers.js file and then after we have update both the users for
    the case of the follow, we create a new Notification object with the type set as "follow", from set as the req.user._id and the 
    to set as the id of the user to whom the follow request was sent. Then, we save this Notification object to the database so that 
    when the user that was followed logs in, he/she is notified. In the database, all the fields are stored including the createdAt
    and updatedAt fields.
19. Now, we move on to the next functionality that is getSuggestedUsers. For this we create a function called getSuggestedUsers
    inside the user.controllers.js file. We need to keep in mind while creating this function that we need to exclude the current
    user from the suggested users array as well as the users that we already follow. For this we get the following list of the current
    user. Then we use the aggregate function of mongodb to get all the users, except the current user and create an array of 10 or so
    such users. Then we filter these users array such that it takes every user of the users array and checks whether that user is in
    the following array of the current user. Then the list of such users is then sliced to just contain 4 elements. Now, for each 
    user from the suggestedUser array is taken and its password is set to null or undefined so that the password of the user is not
    revealed in any way. This setting the password null does not take effect in the database of the app, it only affects the response
    from the app. Then we send a status code of 200 to tell that the request worked and write the error part of the block.
20. Now, we move on to the next functionality of updating the user's profile. A user can update it's username, fullName, email,
    password, bio, link, profileImg and coverImg. we will declare the variables profileImg and coverImg as let as we would like to
    update it further in the code. First, we find the user that is logged in, in the database. Next, we check that both the 
    newPassword as well as currentPassword has been passed by the user. Then we check if the currentPassword matches the one stored
    in the database. To check this, we use the bcrypt package, which we import into the file. Next, we check whether the newPassword
    provided has length more than 6. Once all these checks have been passed, we generate a hash of the newPassword provided by the user
    by passing it through 10 salt rounds and then hashing it as well. Next, we check whether the user wants to update their profileImg
    or coverImg. To code for this, we will use cloudinary and before using it we need to create an account on cloudinary. After 
    creating our account, we go to the dashboard where we get the cloud name and the api secret and the api key and store them as 
    the environment variables in the .env file. Next, we go to server.js file to configure our cloudinary account. Here, we import
    v2 as cloudinary and then config it, passing the environment variables as an object. Now, we can upload and delete images. Now,
    we import cloudinary in the user.controllers.js file and use it to upload the image file to cloudinary. Before uploading
    we need to take care of the pre-existing profileImg and coverImg, we need to delete those before uploading new ones in order to 
    save the free space we have in our cloudinary account. In order to do that, we make use of the public image id used by cloudinary
    to identify a stored image, we get this id by splitting the url by "/" and popping the last part of the url which contains the 
    public_id and then splitting that by the "." to obtain the first part of the string which is the image id. The splitting function
    splits the string into parts before and after the specified char such as "/" or "." and store these parts of string in the array.
    Then, we update the fields passed by the user and if they haven't passed something, we keep those values to be the old ones and 
    finally we save all the values to our database. Then we make our response user.password as undefined and then return the updated
    user.
21. Now, we will add our post controllers. Before that we will add post.model.js. In this we will create the schema of the post model,
    i.e. what will be included in a post for example, the user that will post, the timestamp of createdAt and updatedAt, the text or
    image that will be posted, the likes on the posts which will be an array of user ids, and finally the comments which will be an
    array of text along with the users that wrote that comment referenced using the user id. Then we create a model out of the schema
    and export it. Next, in our server.js file we create an app route for the post route and import the post.routes.js.
22. Now, we create our post routes. We first import express, initialising and exporting router. Next we start defining the routes.
    We define routes to create post, like or unlike a post, comment on a post or delete a post.
23. First we create the handler function for createPost and import this to the postroutes.js. For creating post, we first take the
    text that the user passes through the request as a const and the image as a variable as we will need to change that variable later
    Then, we get the userId of the user that is logged in and throw errors for user not existing or the user not passing anything. 
    If the user passes an image, we pass it to the cloudinary servers and then save the response secure_url to the img variable. Next,
    we create a new object of the Post model containing the userID, the text or the image. Finally, we save the newPost object to the
    mongodb and send back the new post.
24. Next, we will add the deletePost function handler. For this, we first find the post to be deleted, by using the post id that has
    been passed through the params. Next, we check whether which is logged in currently is allowed to delete the post or not. Then, 
    if the post has an image that needs to be deleted then we delete that image from cloudinary by using the image id, we obtain the
    image id by using the method described above. Then, we delete the post by using the postId passed in the url and by using the 
    mongodb method to delete an object from the database by using its id.
25. Next, we add the comment on post function handler. For that we first get the text that the user wants to post in the comment and
    userID of the user adding the comment. Next, we check whether the comment is empty and if the post even exists or not by finding
    the post that is being commented on, using the id passed in the parameters of the url. Create a newComment object and push this
    object into the comments array of the post. Save this updated post to the database. Next, we add the Notification functionality
    to inform the author of the post that their post was commented on. We save this notification in the database for the author to 
    find it when they login.
26. Now, we add the Like and Unlike functionality. Here we get the postId and the userId first then find the post using the postId 
    and then check whether the post exists or not. Next, we check whether the post is already liked by the user that is logged in.
    If the post is liked, the post is unliked. The likes and unlikes are kept track of with the help of a likes array and the userIds
    of the users that have liked a post. To remove a userId from the likes array, we use the updateOne method. This method is used
    to modify a specific a document (in this case, a post), within the mongodb collection. It is a mongodb method that updates a single
    document in the collection that matches the given filter criteria. The signature of the updateOne method is (filter, update, options)
    filter specifies which document to update, update defines how to update the document. updateOne is used on a Mongoose Model, 
    representing a collection of something, using this function we are telling the mongodb to update one document in the entire
    collection based on the provided filter criteria. If we had an object instance of the collection, that would represent a specific
    object of the collection that we had already fetched from the database. However, when using updateOne(), we are performing a 
    direct update on the database without having to first fetch the document into memory. This is more efficient in cases where you
    just need to modify a document and don't need to interact with the post data in the application. 
    If the post is unliked then the post is liked and the userId of the user liking the post is added to the likes array of the post,
    we save this updated post object to the database and send a notification to the user whose post was liked and save this notification
    to the database.
27. Now, we create a route to get all the posts. This route will also be protected. In this we use the .find() method to get all the
    posts and the sort method to sort them in descending order of createdAt date so that the posts are ordered in the latest order
    of their creation. Next, if there are no posts an empty array is returned. Now, this would work just fine, however, if we wanted
    to get the name of the user as well when we get all the posts, we would need to use another method. This method is called populate.
    Populate is a method used in mongoose to automatically replace the references in a document, with the actual documents they
    refer to. In mongodb, documents can reference other documents using their _id values. The populate() method allows you to retrieve
    the referenced documents in a single query, making it easier to work with related data. Instead of storing all the user's 
    information in the post, you store the user's _id. Later, when querying the post, you can use populate() to replace the user's 
    _id with the full user document. So, in the end of sort, we add the method populate() with the user passed as a parameter meaning
    that the user will be populated. In order to remove any sensitive information from an object while populating, we will pass an 
    object where the path:  will be the user i.e. the object that we want to populate and the select: field will be "-password" to
    remove the password field from the user object that will be populated. In order to populate the comment section users as well
    we will add another populate method with the path set as comments.user meaning we will populate the users that are stored in the
    comments array again deselecting the password using the select field. 
28. Now, if we want to see all the posts that a user has liked, then we need to update our user model in user.model.js and add another
    field called likedPosts array and each post or each document will be a reference to the post model. We need to update this array
    whenever a user likes or unlikes a post. We again use the updateOne method to update the likedPosts array of the User model, 
    removing the postId from the array and adding it back when the user unlikes or likes the post. Now, we write a route to get all
    the liked posts of a user and write its handler function using the userId passed in the params of the getAllLikedPosts to get the
    likedPosts array of the user and then matching each id of the post with all the documents in the Post collections using the Find()
    method. We also populate the post with user and the comments as well.
29. Now, if we want to see the posts of the people we follow only, then we will create a separate route for that as well. We don't
    need to pass anything in the parameters of this route. In its function, we first get the user that is logged in, next we get the
    following array of this user and then finally get the posts that are posted by the people that the user is following by using
    the Find() function on the Post collection, passing all the userId of the following array, to filter out the posts authored by the 
    following of the user that is logged in, we sort these posts according to the time they were createdAt and populate the users of 
    the posts as well as the comments.
30. Now, if we want to see the posts of a specific user, then we create a route for that as well. The route takes the username of the
    user whose posts we want to see as a parameter. We use this parameter to find the user with that username and save it into the
    user const, we use this user object to get the _id of the user we want to see the posts of and use this userID to find all the
    posts of that user by again using the Find() function. We sort these posts in descending order of their creation and populate the
    users in the posts as well as the comments.
31. Now, we go ahead and make the notification routes. We add the app.use to the server.js for the notification routes and import it.
    We create a notification.routes.js in the routes folder. Next, we import express in it and create express.router. Then we add three
    routes to it, one to get all the notfications, one to delete all notifications and one to delete only one notification. For deleting
    one notification, we will have to pass the notification id as a parameter. Now, we write the controllers.
32. For the getNotifications handler, we first get the userId of the user who is logged in and is checking their notifications. Next, we
    find all the notifications, from the notifications collection, that are addressed to this logged in user by using the find() method
    and passing it the userId for the to: field and we populate the from field of the notification and we only select the username and
    profileImg because those are the only two fields that we want in our notifications. Next, we update the read field of the notification
    to be true.
33. For the deleteNotifications handler we get the userId of the user that is logged in and check the Notifications collections for the
    notifications corresponding to the currently logged in user and delete all of those.
34. For the deleteNotification handler we also get the notificationId from the parameter of the route. We find the notification and check
    whether the notification actually exists or if the user is even allowed to delete the notification or not. If all these checks are 
    passed, the notification is found and deleted using the notificationId.
35. Now, its time to deal with the frontend. First we cd over into the frontend folder and type the command 'npm run dev'. We want to 
    change the port of this app to 3000, for that we go into the vite.config.js inside the defineConfig function we add the server field
    which takes in an object with the attribute of port set to 3000.
36. Next, we would like to install tailwing and daisyUI. To install tailwind we type tailwind css vite install inside google and go to
    site of tailwind. In there, the first step is to create a vite app which we have already done. The next command is to install the 
    tailwind css. We paste that command into the terminal after cd-ing into the frontend folder. This command will then create a
    tailwind.config.js file. The next step says to copy the text given on site and modify the tailwind.config.js file with that text.
    Next, we update the index.css file by deleting everything that was previously in it and replacing it with the text given in step 4.
    These are basically tailwind css directives that we follow so that we can use the classes that are coming with tailwind css, just like
    react, bootstrap etc.
37. Next, we are going to install DaisyUI using docs. It is a components library for tailwind which makes it easier to get components in a 
    website without typing too much code. We first type in the command to install daisyUI and then add it as a plugin inside the tailwind.config.js
    file. We are using ESM so we will first import daisyUI and the add daisyUI to the plugin. To test whether it works we can try to render
    a component from the components section of the daisyUI website and pasting it in the return statement of the App.jsx. DaisyUI gives us
    some color or some theme by default but if we want to extend it with our own colors we can do it, for that we go to the documentation
    of DaisyUI and then go to the themes dropdown and choose a theme that we want. If we go to the themes sidebar we will get different
    themes that they have and how to extend the current theme. So, we go to the github repo and take the code from the first code box and
    paste it into the tailwind.config.js file. In the code we are using the light theme as well as the dark theme and extending it with two
    different colors, one is twitter blue and the other is some form of black. To test whether it is working we can add the btn-primary class
    to a button. Now, to be able to get the black theme, we add 'data-theme = "black"' to the html tag in index.html file. We will also 
    update the title of the HTML to be 'X Clone'. Now, the theme has changed, so does the color of the button.
38. Now, we will install react router and react icons, command given in the github repo ( npm install react-router-dom react-icons). We
    are installing the react router dom so that we could add different pages into our application and handle the routing. Next, we need 
    to wrap the App component with BrowserRouter in main.jsx. With the help of this now we can use any component that is coming from the 
    react-router-dom package under the App component.
39. Now, to be able to add different pages such as login, sign up and homepage we could use the <Routes> as well as <Route> component. We
    follow the github repo after this. Source: https://github.com/burakorkmez/twitter-clone/blob/master/UI-DESIGN-STEPS.md We add the div
    that contains the flex max-w-6xl mx-auto classes and to it add the Routes component. To this Routes component we add a Route component
    for the HomePage along with two other Route components, one for login and one for signup
40. Now, we first create the signup page under the path /src/pages/auth/signup/SignUpPage.jsx. Install the extension 
    ES7+ React/Redux/React-Native snippets so that we can get autocomplete for React snippets. Like typing rafce will give React Arrow 
    function export component. Similarly, we create the pages, /src/pages/auth/login/LoginPage.jsx and /src/pages/home/HomePage.jsx and
    add the rafce snippet to each of them and import them inside App.jsx and use them in each of the Route components. Make sure we have
    imported everything in App.jsx and main.jsx
41. Next, we copy the code for the SignUpPage from the GitHub repo and paste it in the SignUpPage.jsx. In order for that code to work we
    also need to add the svg for X, steps for which are mentioned in the repo as well. We can get icons from React icons. Next, we add the
    code to the login page and after that to the home page. For the home page, we create two more files, we create CreatePost.jsx file inside
    the home folder because that is the only component where it will be used and the Posts.jsx inside the /src/components/common folder 
    because this component will be used commonly throughout the app. We add boilerplate code to both the files for now. Next, we create the
    Sidebar.jsx component as well, inside the common folder as this will also be a common component and paste the code from the GitHub repo
    into it. Now, we also need to add the Sidebar component to the App as well. We will add it just before the Routes component in App.jsx
    If we put anything outside the Routes component it will be a common component. Next, we add some dummy data in the path,
    /src/utils/db/dummy.js and also create a Right panel component in the common folder with the file name as RightPanel.jsx we also need
    to import it in the App.jsx for the component to show up, so we will add it after and outside the Routes component and hence it will
    be a shared component in all pages because it is outside of the Routes component. Next, we add something called a skeleton which is 
    basically a component that shows up for a split second just when the site is loading to give a cool loading effect. Different skeletons
    can be found in the components of the daisyUI documentation. When the isLoading variable is true, the component will show the skeleton
    component/UI and when it is false it will load the actual data. Next, we add code to the CreatePost.jsx file. After this we create the 
    Post.jsx component and the PostSkeleton.jsx component for the Posts.jsx code. Next we add the NotificationPage.jsx to the path
    /src/pages/notification/NotificationPage.jsx and add a Route to it in the App.jsx inside the Routes component. For the rest of the UI,
    keep copying and pasting from the GitHub repo, following the instructions in it.
42. Now, we will connect the API from the react app that we have and in this part we will need data fetching and data manipulation which is
    something like creating, updating and deleting and for that we will be using a package called react query or also known as TanStack
    Query which is a library that allows you to fetch, cache and update data in your react apps and it is a great alternative to Redux and
    other state management libraries. We will install it from the installation tab, pasting the command in the terminal installing it in the
    frontend folder of the project. Once the library is installed we will initialize it inside the main.jsx and we need to wrap our App
    component with it. First we create something called as queryClient which is coming from TanStack so we will import QueryClient and 
    QueryClientProvider from the tanstack/react-query. Then we wrap our App component with QueryClientProvider with the client attribute 
    in the opening tag set to {queryClient}. Now, with the help of this wrapping, we are able to use anything coming from this package
    in our application.
43. Next, we are going to add the sign up functionality. In the react code we have a state with the email, username, fullName and password
    a handleSubmit button which we call on submitting the form. We need to signup the user instead of console.log-ing what the user provided,
    when the submit button is pressed and for this we need to use mutation. We use mutation when we need to manipulate the data like creating,
    updating and deleting and we use useQuery when we need to fetch the data. We add both after the useState that creates the state for form data.
    We destructure useMutation which returns different states such as the mutate function and then things like isError, isPending for loading
    states, error. Make sure to delete the already hard-coded isError function from the code, we will be using the Dynamic value from the 
    backend. Now, inside the useMutate's parentheses, the first thing that we are going to need is something called mutationFn and its
    going to be an async function that we pass and it will have a try-catch in it. This async function will take fields like email,
    username, fullName and password and in the try we would just like to send a fetch request. Now, in order to make it easier
    for us to pass the url everytime we make a fetch request, we will simply pass 'api/auth/signup' to the fetch and to be able
    to access using just that we will have to update the vite.config.js. In this file, under the server, we will have a proxy field,
    which will take the value for the target api and change the Origin. Basically, whenever it will see /api in a url, it will take the
    target we passed and prefix /api with it. Then, the next thing that we would like to pass to the fetch function will be the type of 
    method which will be "POST" in case of signup, the headers, and then we will stringify the body and then we are going to get data out
    of this. Before this we also add a check whether the response was ok or not. Another check can be added to throw an error if there's 
    an error in the data, otherwise we can console.log the data and return the data. Now, in the catch part, instead of console logging
    the error we try to handle it. For this we are going to use a package called React Hot Toast. First we will need to install that package.
    For that we type the command 'npm install react-hot-toast' in our frontend folder. After this we need to add a component called <Toaster />
    in App.jsx at the end of all the previous components. That way we will be able to use that toast, so we call the toast function in our
    catch block and deal with the error. Also, when we submit the form, we would like to call mutate function, so instead of console logging
    the form data, we will just say mutate and pass the formData into it and that form data has those fields that we passed in the mutate
    function. We could have the isPending state in the signUp button to change the text to Loading or Sign Up depending on the isPending 
    state. We also replace the Something went wrong text with the {error.message} text. In the mutationFn we also pass onSuccess function
    to give a message when the account has been created. In the catch error part, since we are handling the error below, we can just throw
    error in the catch block. Also, for a more specific error, we can move the if(!res.ok) statement below the data variable and throw the
    data.error in it and if there is no data.error then we can just throw 'Failed to create account' and hence remove the redundant if(data.error)
    statement.
44. Now, we move on to the LoginPage.jsx, we do the same things that we did in the SignUpPage.jsx. We rename the mutate to LoginMutation
    for more readable code.
45. Now, we move on to add the LogOut functionality for that we go to Sidebar.jsx. We destructure the useMutation and we don't need to 
    pass any data to the mutationFn because we are just logging out the user. We add a try catch block in it and fetch the response in which
    we only pass the method which will be POST and skip the headers. Next, we will get the data and then handle the errors and the onSuccess.
    We will also call the mutate function, which we rename as Logout on clicking the logout button so we will add that as well. But first,
    we will try to prevent default because it is wrapped under a link, if we don't prevent default then it is going to take us to that user
    page, instead of that we want to logout. After preventDefault we add the Logout function call. Now, to check whether this is working
    or not, we go to the login page and before logging out, in the developer mode->Application->Cookies we check for any pre-existing cookies
    i.e. jwt tokens if they exist, when we click the logout icon, the cookie should be deleted and when we try to login a new jwt token
    should appear.
46. Now, we go into the App.jsx to fetch the currently authenticated user and for that we had an endpoint under the auth called "/me" that
    will give us the currently authenticated user. We would like to call that in our App.jsx and to be able to fetch some data or to send
    some GET request we would use useQuery from the package. This is going to give us some values like data, isLoading (instead of isPending)
    and this is going take an object where we would pass the queryKey which is an array with the string "authUser" followed by queryFn which
    is an async function in which there will be a try-catch block in which first we will get the response from the api endpoint /me and
    store the res.json in the data variable then we will error handle then console log the data of the user who is authorised and return
    the data. The catch block will throw the error. After the useQuery() we add the isLoading check which returns the LoadingSpinner if
    the isLoading is true.
47. Now, let's also make our routes protected so if we are authenticated, we shouldn't be able to visit the login page and if we aren't 
    authenticated then we shouldn't be able to visit the homepage. Now, if we logout and try to visit the homepage, we can still visit 
    it, it just tries to load as react query by default will try to send three different requests until it gets a response, so it just
    tries to make sure if server is not crashed. First, we will rename the data to be 'authUser'. Now, in the Route component of the 
    HomePage, we will say if we have the authUser then show the HomePage but else Navigate the user to the /login page and in the Route
    component of the LoginPage, we will say if we don't have the authUser then show the client the login page or else Navigate them to 
    the HomePage and we can do the exact same thing for the signup as well and repeat the same thing we did for homepage, for the 
    notification as well as the profile page. Now, if we change the tabs, the page will refresh when we come back, this is the default 
    behaviour of react query and we want to change that. For that we are going to change the main.jsx and in it we are going to pass the
    queryClient an option called defaultOptions that will change the default for everything in the app. In this we will change the queries
    object, refetcOnhWindowFocus property to false. This will apply to every single query in our App. If we don't want to add it to all of
    them i.e. if you don't want to add it to a single query, we could just come to the queryClient and just add the queries one by one.
    We are passing a queryKey so that in other files we could refer to this query. So, if we want to call the authUser again we don't 
    need to call that function. Suppose if we wanted to use authUser in our ProfilePage file, then we will call the useQuery function and
    pass it the object with the queryKey set as 'authUser'. With this, we are just calling the query to give us that data, we don't need
    to pass the queryFn function. You can also update the cache, revalidate or invalidate the queries. So, we will use queryKey to reference
    the queries. If we don't want to see the loading window for too long, we can add another option after the queryFn to set the retry to
    be False. Now, it will not try to GET the page 3 times after failing once. Now in our LoginPage.jsx, onSuccess, we need to redirect to
    the homepage and for this we have a concept called invalidating queries, basically it is going to refetch the query that we'd like to 
    refetch. So, once we successfully log in, instead of showing a toast we're going to just invalidate the authUser query so basically
    refetch the authUser to be able to update the UI. For refetching we need to get the queryClient (it is a hook). Then we use that
    queryClient hook to invalidate the queries, the query we want to invalidate is the authUser and we do that in the onSuccess.
48. If we do the same thing that we did in the LoginPage.jsx above, to the logout page it won't work, this is because even if we don't
    have the authenticated user, the data field (that we renamed as authUser) is just going to be an empty object. When you invalidate the
    query, it returns an empty object. In order to be able to fix this, in the queryFn after declaring the data variable, we will check if
    there is data.error, which if there is, will mean the user is unauthorized, we will just return null. Once we do this it should run.
    To remove the Sidebar and RightPanel we just wrap those components with an AND with the authUser. Now, we try to remove the hard
    coded data from the sidebar and try to display the authenticated user in the sidebar. For that we are going to call the authenticated
    user. Since we have the queryKey we can refer to it using the useQuery hook, we destructure this and replace the 'data' variable
    everywhere with 'authUser' which is the variable that we have renamed 'data' to.
49. Now, we add the functionality where when we click on the 'For You' it fetches all the posts in the database and when we click the
    'Following' we get all the posts that the user's following have posted. For this, we need to go to Posts.jsx. This Posts will first 
    take a field called 'feedType' which can either be 'For You' or 'Following' and we are going to use this prop to change the endpoint.
    We create a function called getPostEndpoint. In this function we use a swtich statement to return an endpoint based on the feedType
    variable value. We store this return value to POST_ENDPOOINT variable which calls the getPostEndpoint function. Now, we use the 
    useQuery hook to get the data which we rename as posts and the isLoading variable, deleting the one that we hard-coded earlier. In 
    this we define the queryKey as "posts" and the queryFn where it fetches the endpoint and the data from that endpoint. We error check
    the response and return the data. Now, below, in the return statement of the Posts.jsx, we replace the hard coded POSTS data with 
    the data that we fetched above. Also, delete the import of the hardcoded data after replacing all the POSTS. Then, we go into the 
    Post.jsx where we take the post as a prop and just render the fullName, username, post image, post content. Finally we go to the 
    HomePage.jsx and pass the feedType as feedType to the Posts component on line 40. So, when you click that button its going to update
    that state. Now, we need to refetch the data when it changes state, the response is in the cache so it is the same so it doesn't try
    to fetch that. This is something that we can get from react-query as well as a field called isRefetching which is the loading state for
    refetch and we can call this whenever the feedType changes. So, after the useQUery, we call the useEffect and when the feedType changes
    we are going to call the refetch function. We pass refetch with feedType in this so that it doesn't give us any warning and if it is
    refetching we could show the loading skeleton as well and when it is NOT fetching then we can show the posts.
50. Now, we add the DELETE Post functionality. Now, the all of the users can see the delete button on every post, we need to change that
    such that only the owners of the post can see the button and delete their own post and no one else. For that we go to Post.jsx, Here
    the isMyPost = true is a hard-coded data and we need to change it to a user-specific data so we get the authenticated user using the
    useQuery and the queryKey. Now, we check if the user is the owner of the post or not if it is so, only then we show the trash icon.
    Now, when we click this icon, we want to call a function that deletes the post i.e. handleDeletePost and we are going to call the
    mutation. In this we fetch the post using the postId and pass the DELETE method to it to delete it. After the mutationFn we add the 
    onSuccess in which we add the toast that the Post has been deleted successfully and invalidate the query by first declaring a variable 
    calling the function useQueryClient and then using it to invalidate it using the queryKey. We also use the isPending state to show or 
    remove the trash icon and the Loading Spinner.
51. Now, we add the functionality to create a Post for that we go inside CreatePost.jsx. In this component, we have two states to hold the
    text as well as image and we have an imageRef so that when we click on the image icon, we could open up an image file explorer. Then,
    we have some hardcoded data with two more variables for pending and error state which we will replace with the value coming from the
    react-query and when we submit the form we're going to get the alert that says post created successfully and then a function to render
    the image on the client. Now, first we get the authenticated user using the react-query, then we are going to get the queryClient 
    because we will be invalidating the queries, we're going to update the cache. When we submit the form, we are going to call a function
    called createPost in which we are going to pass the text as well as the image. The createPost is going to be the mutate function that
    we call now. The mutationFn will take the text and image as the two input parameters and we will send a POST request to be able to
    create the post. We will get the response data back and handle all the errors. After the mutationFn we will add the onSuccess function
    that will show a Post created toast and invalidate the query and also set the text and image field of the post creating window as
    empty string and null. When we try to upload a image of size greater than 100kb, error is thrown this is because this is the default
    limit set for the size of the image that can be uploaded in a post. To change that we go to the backend folder to the server.js file
    and in the app.use(express.json()) we pass the field 'limit' and the value 5mb to it so that we can upload an image of upto 5mb now.
    This limit shouldn't be too large because if an attacker sends too large requests to our application then our server will crash due
    to denial of service.
52. Now, we move on to the suggested user functionality or component. We will add real users to it instead of the hard coded data. We 
    delete the hardcoded isLoading variable and add a useQuery hook. We are creating a query for getting the suggestedUsers from the
    backend for that we fetch it from the api route we specified in the backend and save it in the suggestedUsers variable which we replace
    in the entire component in place of the hard coded data. Now, if we had no users in our database or a user followed everyone in the 
    database, basically if the length of the suggestedUsers array was 0 then we would want to display a fake div component in place of
    the small box of suggested users so that the posts container of the website doesn't stretch and occupy the empty space. For that we add 
    a check for this just before the return statement.
53. Now, we are going to add the follow/unfollow functionality. For that we are not going to the RightPanel and just write the code there, 
    we are not going to add that functionality to this component and the reason is we would like to make this reusable, we would like to 
    use this functionality both in the right panel as well as the profile page. For this we are going to create a custom hook and use that
    in both the places. For that we will go under /frontend/src and create a folder called hooks and inside this we create a file named
    useFollow.jsx, which will be a reusable file. First we will import the toast and useMutation files. We create a variable named
    useFollow which we export as default in this we create a variable named queryClient to invalidate some queries. Then we call the 
    useMutation and name the mutate function as follow and write the mutationFn in which we pass the userId of the user that we want to 
    follow and then fetch the endpoint for following the user, the method is POST and we save the response that we get into the data and
    handle the errors. We add an onError which displays the error as a toast. In the onSuccess we will invalidate two queries, the first
    one is going to be the suggested users that we fetched because if we followed a user from that container then we don't want to see that
    user in that container. The other query that we will invalidate is going to be the authUser, the reason is because when we are going
    to follow a user from their profile, we are going to update the button to be unfollow and to be able to implement this we need to fetch
    the user profile, the authenticated user because we are going to be using a field called following or the followers. If we want to 
    invalidate more than one queries, we can just Promise.all() so that they can run in parallel so that they execute that much faster.
    Finally we return the follow and isPending from the hook. Now, we go to the RightPanel.jsx and when we click the follow button we would
    like to call the mutation. We call the useFollow function and save the data it returns to the variables follow and isPending, we can 
    use the follow functionality by simply doing that. Now, we go to the follow button component and to the onClick event handler, we add
    the function call to follow function passing the user._id along to it. We can also add a loading state in which if it is pending
    then it will show the LoadingSpinner else we will say follow, remember to import the LoadingSpinner component.