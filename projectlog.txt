1.  Create the project file "Twitter Clone"
2.  Add two folders to it, one named "backend" the other named "frontend" 
3.  In the frontend folder, initialise a new react app. To do that first cd into the frontend folder then in the terminal type the
    command "npm vite@latest .", the dot at the end is for when we want the react app to be initialised under the frontend folder,
    i.e. under the same folder that we have cd into, else it would prompt us to name a new directory for creating the app, select Y
    when prompted then "React" when prompted then "JavaScript" when prompted.
    Now run the command "npm i" to install all the node modules and dependencies and once that has been done run "npm run dev" to 
    see the boiler plate react app.
4.  Now to be able to create a backend we will cd into the backend folder. Before that we will run the command "npm init -y" in
    the root just to have a better developer experience when we deploy this app. This command will give us the package.json file, so
    that we could install our dependencies. For the backend we would like to install a couple of dependencies. So, run the 
    "npm install express mongoose jsonwebtoken bcryptjs dotenv cors cookie-parser cloudinary"
    express: to create our api or the express server
    mongoose: to interact with our mongodb database
    jsonwebtoken: for authentication
    bcryptjs: to be able to hash passwords
    dotenv: to be able to read the content of .env file
    cors: to be able to get rid of cors errors
    cookie-parser: to be able to get the cookies from the request
    cloudinary: (package/service) so that we could upload images for free
    The above command will install all the packages and put the node modules in our root. We also install a dev dependency, for
    that the command will be "npm i -D nodemon". Add the "type" key in the package.json file below the "author" key and set it to
    "module" in order to use the import and export syntax. For the scripts, delete the "test" key and then write
    ' "dev":"nodemon backend/server.js" ' to be able to run nodemon. The "server.js" file will be under the "backend" folder 
    (create one) hence the path after the nodemon. And for the production we will write ' "start" : "node backend/server.js" '
    and this means we want to run this file with node. Our main file is not "index.js" anymore but "server.js" under the "backend"
    folder so we will change the value of the "main" key to "backend/server.js".
    Now, calling the command "npm run dev" will call the "nodemon backend/server.js" and run the server.js file. Since we are 
    using nodemon, whenever we change the server.js file it is just going to update the server and restart the server by default.
    Hence, nodemon is a very useful tool for development.
5.  Create your boilerplate express server in the "server.js" to test it out.
    ' import express from "express";

    const app = express();

    app.get("/", (req,res)=>{
        res.send("Server is ready");
    })

    app.listen(8000, ()=>{
        console.log("Server is up and running on port 8000")
    }) '
6.  Now, that we have our setup, we can setup our other routes. We will have a couple of different services like authentication,
    users, posts, notifications and adding all of these to one file would make the file really large and hard to manage. Hence,
    instead we will put routes in different folders. So, we create a "routes" folder in our backend folder and this folder is 
    going to have some functions and again we can't put all of them into those files so instead we'll like to have some clean code 
    and some manageable and maintainable code base and for that we are going to create a folder called "controllers" and we would 
    like to have some tables in our database and we're going to call them "models" and since we are using mongodb which is a nosql
    database so it is not going to be tables but something called as collections but basically it is the same thing as tables.
7.  We add a middleware using "app.use" which says that when we visit "api/auth" we would like to go to "authRoutes". And this 
    route we need to add to the routes folder by the name of "auth.routes.js" or any other name that we want. In this we add the
    routes that will handle all the authentication endpoints. We use the "express.Router" instance and using this in a const 
    variable we use the HTTP methods that we want to add to the route along with the path that we want it to follow or the 
    endpoint that we want there. In the handler function we add the objects that we want it to return on hitting that endpoint.
    We will use the POST methods for authentication and their handler functions also need to be put in the "auth.controller.js"
    file that is to be created in the "controllers" folder and the reason is that if any of the handler functions become too 
    large, the file will be unmanageable and it is the best practise to create the "controller" folder and the file in it.
8.  To set up our signup functionality, we need a database to store our users and for this we need mongodb. So, we go to the
    mongodb website and signin and create a new project. Then we create a new deployment selecting the free tier leaving the 
    cluster name as it is. Now, this is going to give us a password which we need to copy and then create a .env file in our 
    root folder and paste the password in it. Then we click "Create Database User" and then "Choose a Connection Method",
    select the Drivers because we would like to connect the mongodb with node.js. It will say to install mongodb but we have
    installed mongoose which is better option as it has really great support. Then we will copy the connection string with the
    checkbox checked for "Show Password" and we will paste this string in the .env file as well. As we have copied the string
    with the password, we will delete the previously pasted password from the .env file and set the link string equal to a
    variable, in our case the variable name is MONGO_URI. In the link string, before the '?' symbol we will add the database
    name, in our case twitter-db. And with this we should be able to connect to our mongo database. Now, we will go under the
    "Network Access" and in this there should be our IP address and in this we will add another IP address and then select the
    option "Allow access from anywhere" beccause our IP addresses could change while developing the application and we don't
    want to get any errors.
9.  Now, we can write a function to be able to connect to our database. We installed the dotenv dependency to be able to read the
    .env file content. So, to use this dependency, we first import the dotenv file from dotenv then configure the dotenv by
    "dotenv.config();" and then use "process.env.MONGO_URI" to access the variable. Now, we are going to create a folder called
    "db" and add a file called "connectMongoDB.js". Inside this file we will just create a function to be able to connect. Now, 
    once we listen to our server, once our server is up and running we are going to just say connectMongoDB and just call it.
    We can also add the port number to the .env file and call it in the server.js file along with a default value and set it as
    a variable.
    At this point, you can commit your files to a Git Repo. For that, we move the .gitignore file from the frontend folder to
    the root folder and add the .env add the end of it. Then in a new terminal with the folder set as the root directory we call
    'git init' and then stage our changes using the Git extension of vscode and then add our commit message and then commit.
10. Now, we will first try to create our user model. So, we will add the "user.model.js" file to the "models" folder of the
    backend. A model is kind of a table and since we are using nosql its going to be like a collection. In this we create the 
    user schema with the first object passed in the schema being the various attributes of that schema/ fields of the user along 
    with its constraints like type, required, unique etc. The second object to be passed in the Schema call is optional but useful
    when we want to add member since: or created on: or updated on: fields for the user, for this we set the timestamp key as true.
    Once the schema is done, we created the model User using the line mongoose.model("User", userSchema); and then exported User model
11. Now, with our User model implemented and exported we can implement the user authentication route and specifically the signup
    function. So in the auth.controller.js file we implement the handler functions. We need to get some fields from the user like
    fullName, userName, email, password and we will get that from req.body but we cannot get this without using the middleware.
    Middleware is just a function that runs before you do anything or after you do everything or just something in between, the thing
    to remember is that it is a reqular function that runs between request and response. In our case we will use the express.json 
    middleware in order to be able to parse the request body or the req.body and that is going to be the form data that is coming
    from the user from the React application. Now that we have all those fields, for signup, first we check whether the email given
    by the user in the signup form is valid or not, we check that using a regular expression and the test method. After this we 
    check whether the user already has an account or not by checking in our user database if the email given by the user matches any
    email already stored in the database, we do the same for username as well. After this, we hash the password provided by the user.
    For this we use the bcrypt package. First we import the package bcrypt, then we generate the salt using the genSalt method and 
    the generation of salt takes time so we add the await keyword in front of it. The genSalt method takes the salt length value as
    a parameter and the optimal value is considered to be 10, the larger this value the longer it takes for the salt to be generated.
    Then we call the hash method and pass it the password that the user filled in the form and the salt that was generated. Now, we 
    create an object for the new user called newUser object which has the instance of the User model which is passed the object with 
    the passed values and the hashedpassword. Now, once we have the user we would like to generate a token and set the cookie and
    this token will be jsonwebtoken. For this we write an if-else statement in which if the user is generated successfully then we
    call the generateTokenAndSetCookie function that has not been created yet but will take the parameter as the newUser._id and the
    res or response. Next, we save the user information to the database using the save method and finally send a status code of 201
    with the json containing the users information including it's profileImg coverImg etc. set as the default value, finally we send
    a 400 error in the else case and a 500 error in the catch block with a debugging friendly logging of the error.
12. Now, we move on to create the generateTokenAndSetCookie method. For that we create a new folder in our backend folder called
    "lib" and inside this folder we create another folder called "utils" and inside this we create the generateToken.js file. In this
    file we first import the jwt from jsonwebtoken and then export the function that we created generateTokenAndSetCookie, inside this
    it takes the parameter as the userId as well as the res because we're going to set a cookie and send it back to the client as a 
    response. In this we create the const token that calls the sign method that takes the userId as a payload so that we could identify
    this user with some value and that is going to be the userId, as well as something called as the JWT_SECRET, we also set the 
    duration in which the cookie will expire. We need to create the JWT_SECRET in our .env file. This could be any value but we will
    create a long one using our terminal. Open the GitBash terminal and type the command "openssl rand -base64 32" and this will give 
    us a value that we can just copy and paste it in our .env file to be saved into a variable JWT_SECRET. With our secret set, we now 
    have the token and we would like to send it to the client as a cookie. For that we set first the name of the cookie, then we pass
    the token that we want the server to send to the client and then the properties of the cookie that we want to set such as 
    maximum age of the cookie, whether it cannot be accessed by client side i.e. httpOnly, the sameSite attribute for CSRF attacks, 
    whether we want to use the https protocol to send the cookie or not. For https too we will need to set another node environment 
    variable in our .env file that will be set to the string "development" until we are in the development phase and once we deploy
    our application, it will be changed to "production". Now to test this out, we will use PostMan. To do that, first create a
    workspace for your project, then add a collection called AUTH to the workspace, inside that add a request with name SIGNUP and
    the method POST and then in the URL add the protocol name (http://) followed by localhost: followed by our port number of The
    application, followed by /api/auth/signup, then we go to the body tab under it the raw type and the dropdown being JSON. But,
    instead of passing all the user inputs in a JSON file, it is more convenient to use the form-urlencoded way, so we add another
    middleware in the server.js file, just after the app.use(express.json) for parsing the urlencoded form data from the request.
    Then we pass the attribute that we want to set as the key in the form, the name of the attribute should be exactly the same as
    that used in the backend. Make sure that you are sending the form input through body and urlencoded and not the params tab.
    We can check the entries in our database by going to mongodb and database.
13. Now, we will add the login functionality. For this too we will use a try-catch block with the catch block having the same code
    as the signup controller. Here, we will take the username and password from the req.body and then first check to see if the user
    actually exists or not in the database. Then we will go ahead and check if the password provided by the user is correct or not,
    given that the user actaully exists. If the user is genuine, then we will generate a cookie for that user and send it to the user,
    just like in signup.
14. Now, the logout functionality is very easy to implement, we just send a cookie as a response to the post request with its maxage
    as 0 so that it immediately kills that and then return a res status of 200. 
15. One last controller that we need to add is the getMe which will get the authenticated user. This will be used to check whether the
    user is authenticated or not. To implement this, we initiate the try-catch block inside this we try to find the user by user._id
    taking it from the req.body, but in request, we don't have the user._id field so we need to add this first. So in our 
    auth.routes.js file, we have three different post methods, and at the top we will create another one router.get where we get the
    currently authenticated user, but this should be a protected function so we add a middleware, in between the endpoint and the 
    function name called protectRoute and then we create a folder in the backend folder called the "middleware" and inside this we
    add the protectRoute.js file. The reason behind validating the authentication of the user is that whenever we want to perform some 
    other functionalities, we need to be sure that it is infact the user is using that functionality, for that we send the cookie to 
    the server and the server decodes this cookie to authenticate the user and perform the functionality that the user wanted to 
    perform. To do this validity check, we write the protectRoute function using the try-catch block. In this too we first try to get 
    the token from the req but we need a middleware to parse the cookie so we use the cookieParser middleware and add it to the 
    server.js, now the token can be obtained. Now, if there is no token, we throw a token not found error, however, if there is in 
    fact a token, then that token is decoded using the JWT_SECRET that we stored. And if the decoded returns some faulty value or it
    is expired then we will return invalid token. Then we find the user by its id that was passed as a payload and exclude the 
    password field from it. Next we add a just in case for user not being found and finally we set the user object of the request
    equal to the user and then we call the next function. So, in our protectRoute, basically we are getting the token from the cookies
    and if there is not a token, we handle it, if there is a cookie but it is invalid, again we handle it, and we need to verify this
    token with that secret that we have created previously and if we pass this then it means we have a valid token and we use the 
    valid userId to find our user in the database while removing the password field from it and pass this to the req object. Then the
    next is going to call the next function i.e. getMe in this case. Now, in the getMe function, we can use the req.user._id and 
    send that user back to the client. With this, we have all of our controllers in place for our authenication.
16. Now, we move on to the user controller functions. For that, we will add the route so that whenever we go to the /users route, it
    goes through the userRoutes. Now, we create a user.routes.js file in our routes folder and import it into our server.js. Inside
    the user.routes.js file we add the different endpoints that we want to handle like the profile of the user, the suggestions that
    we will provide to the user will also be handled in this route, the follow and unfollow endpoint and the profile updation route.
    All of these routes will also be protected i.e. the user would need to be authenticated to access all these endpoints for obvious
    reasons. Now, we will create the functions that will be called on visiting the specific endpoints. To do that first we create 
    user.routes.js file under the routes folder and inside this file, we add the handler functions. The first function is to get the
    user profile, we are going to be using this when we visit a user profile, so in the profile page where we can see their name, 
    username, folllowers, following etc. To get the user profile, we will take the user name from the params of the URL and use it to
    find the user. 
17. Next, we write the function for the followUnfollow handler. The catch block for this one will be similar to the previous one.
    Now, in this endpoint too, we are passing a param of id which we will use to find which user we would like to follow or unfollow.
    Now, there are two different users that we would like to modify, the user that we would like to follow or unfollow and the current
    user. We will use the id passed as params to get the user to modify and the current user as the user._id that we specified in 
    the protectRoute i.e. the user who wants to follow or unfollow. Now, we perform basic checks to see whether the user is not
    following himself/herself or if the user to modify or the current user exists or not. Then we will check whether the user already
    follows the user or not, if it does follow the user, it will unfollow the user and if it doesn't follow the user then it will
    follow the user. So, if user 1 follows user 2 then user 1 will have an id added to its following array and the user 2 will have
    an id added to its followers array and vice versa happens for unfollowing a user. For adding an id into the array we use the push
    operation of mongodb and the pull operation to remove an id from the array.

18. Now, we add the notifications functionality to the follow/unfollow i.e. a notification will be sent to the user that was followed
    informing them about who followed them but no notification will be given to inform them when they are unfollowed by someone else.
    In order to implement the notification functionality we will create a notification model inside the models folder with the name
    notification.model.js. Inside it we will import mongoose and then create a notification schema and add the timestamps parameter
    to it for later use. Each notification will have a from field, to field, type field and read field. Now, we create a model of the
    Notification schema and export it. We import this in the user.controllers.js file and then after we have update both the users for
    the case of the follow, we create a new Notification object with the type set as "follow", from set as the req.user._id and the 
    to set as the id of the user to whom the follow request was sent. Then, we save this Notification object to the database so that 
    when the user that was followed logs in, he/she is notified. In the database, all the fields are stored including the createdAt
    and updatedAt fields.
19. Now, we move on to the next functionality that is getSuggestedUsers. For this we create a function called getSuggestedUsers
    inside the user.controllers.js file. We need to keep in mind while creating this function that we need to exclude the current
    user from the suggested users array as well as the users that we already follow. For this we get the following list of the current
    user. Then we use the aggregate function of mongodb to get all the users, except the current user and create an array of 10 or so
    such users. Then we filter these users array such that it takes every user of the users array and checks whether that user is in
    the following array of the current user. Then the list of such users is then sliced to just contain 4 elements. Now, for each 
    user from the suggestedUser array is taken and its password is set to null or undefined so that the password of the user is not
    revealed in any way. This setting the password null does not take effect in the database of the app, it only affects the response
    from the app. Then we send a status code of 200 to tell that the request worked and write the error part of the block.
20. Now, we move on to the next functionality of updating the user's profile. A user can update it's username, fullName, email,
    password, bio, link, profileImg and coverImg. we will declare the variables profileImg and coverImg as let as we would like to
    update it further in the code. First, we find the user that is logged in, in the database. Next, we check that both the 
    newPassword as well as currentPassword has been passed by the user. Then we check if the currentPassword matches the one stored
    in the database. To check this, we use the bcrypt package, which we import into the file. Next, we check whether the newPassword
    provided has length more than 6. Once all these checks have been passed, we generate a hash of the newPassword provided by the user
    by passing it through 10 salt rounds and then hashing it as well. Next, we check whether the user wants to update their profileImg
    or coverImg. To code for this, we will use cloudinary and before using it we need to create an account on cloudinary. After 
    creating our account, we go to the dashboard where we get the cloud name and the api secret and the api key and store them as 
    the environment variables in the .env file. Next, we go to server.js file to configure our cloudinary account. Here, we import
    v2 as cloudinary and then config it, passing the environment variables as an object. Now, we can upload and delete images. Now,
    we import cloudinary in the user.controllers.js file and use it to upload the image file to cloudinary. Before uploading
    we need to take care of the pre-existing profileImg and coverImg, we need to delete those before uploading new ones in order to 
    save the free space we have in our cloudinary account. In order to do that, we make use of the public image id used by cloudinary
    to identify a stored image, we get this id by splitting the url by "/" and popping the last part of the url which contains the 
    public_id and then splitting that by the "." to obtain the first part of the string which is the image id. The splitting function
    splits the string into parts before and after the specified char such as "/" or "." and store these parts of string in the array.
    Then, we update the fields passed by the user and if they haven't passed something, we keep those values to be the old ones and 
    finally we save all the values to our database. Then we make our response user.password as undefined and then return the updated
    user.
21. Now, we will add our post controllers. Before that we will add post.model.js. In this we will create the schema of the post model,
    i.e. what will be included in a post for example, the user that will post, the timestamp of createdAt and updatedAt, the text or
    image that will be posted, the likes on the posts which will be an array of user ids, and finally the comments which will be an
    array of text along with the users that wrote that comment referenced using the user id. Then we create a model out of the schema
    and export it. Next, in our server.js file we create an app route for the post route and import the post.routes.js.
22. Now, we create our post routes. We first import express, initialising and exporting router. Next we start defining the routes.
    We define routes to create post, like or unlike a post, comment on a post or delete a post.
23. First we create the handler function for createPost and import this to the postroutes.js. For creating post, we first take the
    text that the user passes through the request as a const and the image as a variable as we will need to change that variable later
    Then, we get the userId of the user that is logged in and throw errors for user not existing or the user not passing anything. 
    If the user passes an image, we pass it to the cloudinary servers and then save the response secure_url to the img variable. Next,
    we create a new object of the Post model containing the userID, the text or the image. Finally, we save the newPost object to the
    mongodb and send back the new post.
24. Next, we will add the deletePost function handler. For this, we first find the post to be deleted, by using the post id that has
    been passed through the params. Next, we check whether which is logged in currently is allowed to delete the post or not. Then, 
    if the post has an image that needs to be deleted then we delete that image from cloudinary by using the image id, we obtain the
    image id by using the method described above. Then, we delete the post by using the postId passed in the url and by using the 
    mongodb method to delete an object from the database by using its id.
25. Next, we add the comment on post function handler. For that we first get the text that the user wants to post in the comment and
    userID of the user adding the comment. Next, we check whether the comment is empty and if the post even exists or not by finding
    the post that is being commented on, using the id passed in the parameters of the url. Create a newComment object and push this
    object into the comments array of the post. Save this updated post to the database. Next, we add the Notification functionality
    to inform the author of the post that their post was commented on. We save this notification in the database for the author to 
    find it when they login.
26. Now, we add the Like and Unlike functionality. Here we get the postId and the userId first then find the post using the postId 
    and then check whether the post exists or not. Next, we check whether the post is already liked by the user that is logged in.
    If the post is liked, the post is unliked. The likes and unlikes are kept track of with the help of a likes array and the userIds
    of the users that have liked a post. To remove a userId from the likes array, we use the updateOne method. This method is used
    to modify a specific a document (in this case, a post), within the mongodb collection. It is a mongodb method that updates a single
    document in the collection that matches the given filter criteria. The signature of the updateOne method is (filter, update, options)
    filter specifies which document to update, update defines how to update the document. updateOne is used on a Mongoose Model, 
    representing a collection of something, using this function we are telling the mongodb to update one document in the entire
    collection based on the provided filter criteria. If we had an object instance of the collection, that would represent a specific
    object of the collection that we had already fetched from the database. However, when using updateOne(), we are performing a 
    direct update on the database without having to first fetch the document into memory. This is more efficient in cases where you
    just need to modify a document and don't need to interact with the post data in the application. 
    If the post is unliked then the post is liked and the userId of the user liking the post is added to the likes array of the post,
    we save this updated post object to the database and send a notification to the user whose post was liked and save this notification
    to the database.
27. Now, we create a route to get all the posts. This route will also be protected. In this we use the .find() method to get all the
    posts and the sort method to sort them in descending order of createdAt date so that the posts are ordered in the latest order
    of their creation. Next, if there are no posts an empty array is returned. Now, this would work just fine, however, if we wanted
    to get the name of the user as well when we get all the posts, we would need to use another method. This method is called populate.
    Populate is a method used in mongoose to automatically replace the references in a document, with the actual documents they
    refer to. In mongodb, documents can reference other documents using their _id values. The populate() method allows you to retrieve
    the referenced documents in a single query, making it easier to work with related data. Instead of storing all the user's 
    information in the post, you store the user's _id. Later, when querying the post, you can use populate() to replace the user's 
    _id with the full user document. So, in the end of sort, we add the method populate() with the user passed as a parameter meaning
    that the user will be populated. In order to remove any sensitive information from an object while populating, we will pass an 
    object where the path:  will be the user i.e. the object that we want to populate and the select: field will be "-password" to
    remove the password field from the user object that will be populated. In order to populate the comment section users as well
    we will add another populate method with the path set as comments.user meaning we will populate the users that are stored in the
    comments array again deselecting the password using the select field. 
28. Now, if we want to see all the posts that a user has liked, then we need to update our user model in user.model.js and add another
    field called likedPosts array and each post or each document will be a reference to the post model. We need to update this array
    whenever a user likes or unlikes a post. We again use the updateOne method to update the likedPosts array of the User model, 
    removing the postId from the array and adding it back when the user unlikes or likes the post. Now, we write a route to get all
    the liked posts of a user and write its handler function using the userId passed in the params of the getAllLikedPosts to get the
    likedPosts array of the user and then matching each id of the post with all the documents in the Post collections using the Find()
    method. We also populate the post with user and the comments as well.
29. Now, if we want to see the posts of the people we follow only, then we will create a separate route for that as well. We don't
    need to pass anything in the parameters of this route. In its function, we first get the user that is logged in, next we get the
    following array of this user and then finally get the posts that are posted by the people that the user is following by using
    the Find() function on the Post collection, passing all the userId of the following array, to filter out the posts authored by the 
    following of the user that is logged in, we sort these posts according to the time they were createdAt and populate the users of 
    the posts as well as the comments.
30. Now, if we want to see the posts of a specific user, then we create a route for that as well. The route takes the username of the
    user whose posts we want to see as a parameter. We use this parameter to find the user with that username and save it into the
    user const, we use this user object to get the _id of the user we want to see the posts of and use this userID to find all the
    posts of that user by again using the Find() function. We sort these posts in descending order of their creation and populate the
    users in the posts as well as the comments.
